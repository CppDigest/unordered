[#regular]
= 常规容器

:idprefix: regular_

Boost.Unordered 闭址容器（`boost::unordered_set`、`boost::unordered_map`、`boost::unordered_multiset` 和 `boost::unordered_multimap`）完全符合 C++ 标准中关于无序关联容器的规范，因此对于了解如何使用 `std::unordered_set`、`std::unordered_map` 等的用户，Boost.Unordered 中的同名容器可以直接替换。开址容器（`boost::unordered_node_set`、`boost::unordered_node_map`、`boost::unordered_flat_set` 和 `boost::unordered_flat_map`）的接口非常相似，但它们存在一些细微差异，这些差异在专门的 xref:compliance.adoc#compliance_open_addressing_containers[标准合规性部分] 中列出。


对于没有哈希容器使用经验但熟悉普通关联容器（`std::set`、`std::map`、`std::multiset` 和 `std::multimap`）的读者，Boost.Unordered 容器的使用方式类似：

[source, cpp]
----
typedef boost::unordered_map<std::string, int> map;
map x;
x["one"] = 1;
x["two"] = 2;
x["three"] = 3;

assert(x.at("one") == 1);
assert(x.find("missing") == x.end());
----

但由于元素是无序的，因此以下代码的输出：

[source, c++]
----
for(const map::value_type& i: x) {
    std::cout<<i.first<<","<<i.second<<"\n";
}
----

可以是任意顺序。例如，可能是：

[source]
----
two,2
one,1
three,3
----

还有其他差异，在 xref:regular.adoc#comparison[与关联容器的比较] 部分列出。

== 迭代器失效

除了 `rehash` 和 `reserve` 外，未规定其他成员函数如何影响桶的数量，尽管 `insert` 仅当插入操作导致容器负载超过允许的最大值时才会使迭代器失效。对于大多数实现，这意味着 `insert` 仅在这种情况下才会改变桶的数量。调用 `insert`、`rehash` 和 `reserve` 可能导致迭代器失效。

至于指针和引用，对于基于节点的容器（`boost::unordered_[multi]set`、`boost::unordered_[multi]map`、`boost::unordered_node_set`、`boost::unordered_node_map`）来说，它们永远不会失效，但对于 `boost::unordered_flat_set` 和 `boost::unordered_flat_map`，当发生重新哈希时，它们会失效：这是因为这些容器将元素直接存储在其持有的桶中，因此当分配新的桶数组时，必须通过移动构造来转移元素。

与为 ``vector`` 使用 `reserve` 类似，在插入大量元素之前调用 `reserve` 是一个好主意。这将避免昂贵的重新哈希操作，并让您可以安全地存储迭代器，因为知道它们不会失效。如果您要在容器 `x` 中插入 `n` 个元素，可以先调用：

```

x.reserve(n);

```

注意:: `reserve(n)` 为至少 `n` 个元素预留空间，分配足够的桶以确保不超过最大负载因子。
+
因为最大负载因子定义为元素数量除以可用桶的总数，所以此函数在逻辑上等价于：
+
```

x.rehash(std::ceil(n / x.max_load_factor()))

```
+
有关 `rehash` 函数的更多详细信息，请参阅 xref:reference/unordered_map.adoc#unordered_map_rehash[参考]。

[#comparison]

:idprefix: comparison_

== 与关联容器的比较

[caption=",",  title='Table {counter:table-counter} Interface differences']
[cols="1,1", frame=all,,  grid=rows]
|===
|关联容器 |无序关联容器

|由排序关系 `Compare` 参数化
|由函数对象 `Hash` 和等价关系 `Pred` 参数化

|可以使用通过成员函数 `key_comp()` 访问的 `key_compare` 来比较键，使用通过成员函数 `value_comp()` 访问的 `value_compare` 来比较值。
|可以使用通过成员函数 `hash_function()` 访问的 `hasher` 对键进行哈希处理，并使用通过成员函数 `key_eq()` 访问的 `key_equal` 检查键的相等性。没有用于比较或哈希值的函数对象。

|构造函数具有用于比较对象的可选额外参数。
|构造函数具有用于初始最小桶数、哈希函数和相等对象的可选额外参数。

|如果 `!Compare(k1, k2) && !Compare(k2, k1)`，则键 `k1` 和 `k2` 被视为等价。
|如果 `Pred(k1, k2)`，则键 `k1` 和 `k2` 被视为等价。

|成员函数 `lower_bound(k)` 和 `upper_bound(k)`
|无等效函数。由于元素无序，`lower_bound` 和 `upper_bound` 将无意义。

|`equal_range(k)` 在 `k` 不存在于容器中时，返回一个位于 `k` 应插入位置的空范围。
|如果 `k` 不存在于容器中，`equal_range(k)` 返回容器末尾的一个范围。它无法返回一个定位范围，因为 `k` 可能被插入到多个位置。 +
**闭址容器：** 要找出 `k` 将被插入的桶，请使用 `bucket(k)`。但请记住，插入操作可能导致容器重新哈希——这意味着元素可能被插入到不同的桶中。

|`iterator` 和 `const_iterator` 属于双向迭代器类别。
|`iterator` 和 `const_iterator` 至少属于前向迭代器类别。

|指向容器元素的迭代器、指针和引用永远不会失效。
|xref:regular.adoc#regular_iterator_invalidation[迭代器可能因调用 insert 或 rehash 而失效]。 +
**基于节点的容器：** 指向容器元素的指针和引用永远不会失效。 +
**扁平容器：** 当发生重新哈希时，指向容器元素的指针和引用会失效。

|迭代器按照比较对象定义的顺序遍历容器。
|迭代器以任意顺序遍历容器，该顺序可能随元素的插入而改变，但等价元素始终相邻。

|无等效功能
|**闭址容器：** 局部迭代器可用于遍历单个桶。（不要求局部迭代器与迭代器的顺序有任何对应关系。）

|可以使用 `==`、`!=`、`<`、`<=`、`>`、`>=` 运算符进行比较。
|可以使用 `==` 和 `!=` 运算符进行比较。

|
|当使用提示插入时，实现允许忽略提示。

|===

---

[caption=",",  title='Table {counter:table-counter} Complexity Guarantees']
[cols="1,1,1", frame=all,,  grid=rows]
|===
|操作 |关联容器 |无序关联容器

|构造空容器
|常数
|O(_n_)，其中 _n_ 为最小桶数。

|从包含 _N_ 个元素的区间构造容器
|O(_N log N_)，若该区间已按 `value_comp()` 排序则为 O(_N_)
|平均情况 O(_N_)，最坏情况 O(_N^2^_)

|插入单个元素
|对数
|平均情况常数，最坏情况线性

|使用提示插入单个元素
|若在提示后立即插入元素则为分摊常数，否则为对数
|平均情况常数，最坏情况线性（即与普通插入相同）。

|插入包含 _N_ 个元素的区间
|_N_ log(`size()` + _N_)
|平均情况 O(_N_)，最坏情况 O(_N_ * `size()`)

|按键 `k` 删除
|O(log(`size()`) + `count(k)`)
|平均情况：O(`count(k)`)，最坏情况：O(`size()`)

|按迭代器删除单个元素
|分摊常数
|平均情况：O(1)，最坏情况：O(`size()`)

|删除包含 _N_ 个元素的区间
|O(log(`size()`) + _N_)
|平均情况：O(_N_)，最坏情况：O(`size()`)

|清空容器
|O(`size()`)
|O(`size()`)

|查找
|对数
|平均情况：O(1)，最坏情况：O(`size()`)

|计数
|O(log(`size()`) + `count(k)`)
|平均情况：O(1)，最坏情况：O(`size()`)

|`equal_range(k)`
|对数
|平均情况：O(`count(k)`)，最坏情况：O(`size()`)

|`lower_bound`、`upper_bound`
|对数
|不适用

|===
